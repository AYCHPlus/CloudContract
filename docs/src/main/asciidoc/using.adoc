[[using]]
= Using Spring Cloud Contract
include::_attributes.adoc[]

This section goes into more detail about how you should use {project-full-name}. It covers topics
such as description of flows of how to work with {{project-full-name}}. We also
cover some {{project-full-name}} best practices.

If you are starting out with {project-full-name}, you should probably read the
_<<getting-started.adoc#getting-started, Getting Started>>_ guide before diving into this
section.

[[flows-provider-nexus]]
== Provider contract testing with stubs in Nexus / Artifactory

You can check the <<getting-started.adoc#getting-started-first-application, Developing Your First Spring Cloud Contract based application>> link to see the provider contract testing with stubs in Nexus / Artifactory flow.

You can also check the https://cloud-samples.spring.io/spring-cloud-contract-samples/tutorials/contracts_on_the_producer_side.html[workshop page] for a step by step instruction on how to do this flow.

[[flows-provider-git]]
== Provider contract testing with stubs in Git

[[flows-cdc-contracts-producer]]
== Consumer Driven Contracts with contracts on the producer side

You can check the <<getting-started.adoc#getting-started-cdc, Step-by-step Guide to Consumer Driven Contracts (CDC) with contracts laying on the producer side>> link to see the Consumer Driven Contracts with contracts on the producer side flow.

[[flows-cdc-contracts-external]]
== Consumer Driven Contracts with contracts in external repo

In this flow, we will perform Consumer Driven Contract testing. The contract definitions will be stored in a separate repository.

You can check the https://cloud-samples.spring.io/spring-cloud-contract-samples/tutorials/contracts_on_the_producer_side.html[workshop page] for a step by step instruction on how to do this flow.

Prerequisites:

* Git repository that
** will contain all the contract defintiions for each producer
** can package the contract definitions in a JAR
** for each contract producer contains a way (e.g. `pom.xml`) to install stubs locally via the Spring Cloud Contract Plugin (SCC Plugin)
** for more information please visit the <<howto.adoc#how-to-common-repo-with-contracts, how to section>> where we describe how to set up such a repository
** for an example of such a project you can {samples_code}/beer_contracts[check the samples]
* Consumer code that has Spring Cloud Contract Stub Runner setup
** for an example of such a project you can {samples_code}/consumer[check the samples]
* Producer code that has Spring Cloud Contract setup together with a plugin
** for an example of such a project you can {samples_code}/producer_with_external_contracts[check the samples]

At a high level the flow looks as follows:

* Consumer works with the contract definitions from the separate repository
* Once the consumer's work is done, a branch with working code is done on the consumer side and a pull request is made to the separate repository with contract definitions
* Producer takes over the pull request to the separate repository with contract definitions and installs the JAR with all contracts locally
* Producer generates tests from the locally stored JAR and writes the missing implementation to make the tests pass
* Once the producer's work is done, the pull request to the repository with contract definitions is merged.
* After the CI tool builds the repository with contract definitions and the JAR with contract definitions gets uploaded to Nexus / Artifactory, the producer can merge their branch
* Finally the consumer can switch to working online to fetch stubs of the producer from a remote location and the branch can be merged to master

[[flows-cdc-contracts-external-consumer]]
=== Consumer Flow

As a consumer

* write a test that would send a request to the producer
** the test will fail due to no server being present
* clone the repository with contract definitions
* set up the your requirements as contract under the folder with your consumer name as a subfolder of the producer. E.g. for a producer `producer` and consumer `consumer` the contracts would be stored under `src/main/resources/contracts/producer/consumer/`)
* once the contracts are defined, install the producer stubs to your local storage e.g.
+
```
$ cd src/main/resource/contracts/producer
$ ./mvnw clean install
```
* setup Spring Cloud Contract (SCC) Stub Runner in your tests
** to fetch the producer stubs from your local storage
** to work in the `stubs per consumer` mode (this enables Consumer Driven Contracts mode)
* SCC Stub Runner will
** fetch the producer stubs
** run an in memory HTTP server stub with the producer stubs
* Now your test communicates with the HTTP server stub and your tests pass
* Create a pull request to the repository with contract definitions, with the new contracts for the producer
* Branch your consumer code, until the producer team has merged their code

[plantuml, flow-overview-consumer-cdc-external-consumer, png]
----
"Consumer"->"Repo\nwith\ncontracts": clone
"Repo\nwith\ncontracts"->"Repo\nwith\ncontracts\nclone": cloned
"Consumer"->"Repo\nwith\ncontracts\nclone": create contract\ndefinitions of\nthe [Producer]
"Repo\nwith\ncontracts\nclone"->"Local storage": install [Producer]\nstubs locally
"Consumer"->"Consumer\nBuild": run tests
"Consumer\nBuild"->"SCC\nStub Runner": Run [Producer] stubs
"SCC\nStub Runner"->"Local storage": fetch [Producer] stubs
"SCC\nStub Runner"->"Producer stub": stub is running
"Consumer\nBuild"->"Producer stub": send a request\nin the tests
"Producer stub"->"Consumer\nBuild": send a response
"Consumer\nBuild"->"Consumer": the tests are passing
"Consumer"->"Repo\nwith\ncontracts\nclone": send a pull request
"Repo\nwith\ncontracts\nclone"->"Repo\nwith\ncontracts": pull request sent
"Consumer"->"Consumer": branch the code
----

[[flows-cdc-contracts-external-producer]]
=== Producer Flow

As a producer

* take over the pull request to the repository with contract definitions. You can do it from the command line
+
```bash
$ git checkout -b the_branch_with_pull_request master
git pull https://github.com/user_id/project_name.git the_branch_with_pull_request
```
* Install the contract definitions e.g.
```bash
$ ./mvnw clean install
```
* Setup your plugin to fetch the contract definitions from a JAR instead of from `src/test/resources/contracts`
+
[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
<plugin>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-contract-maven-plugin</artifactId>
	<version>${spring-cloud-contract.version}</version>
	<extensions>true</extensions>
	<configuration>
		<!-- We want to use the JAR with contracts with the following coordinates -->
		<contractDependency>
			<groupId>com.example</groupId>
			<artifactId>beer-contracts</artifactId>
		</contractDependency>
		<!-- The JAR with contracts should be taken from Maven local -->
		<contractsMode>LOCAL</contractsMode>
		<!-- ... additional configuration -->
	</configuration>
</plugin>
----
+
[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
contracts {
	// We want to use the JAR with contracts with the following coordinates
	// group id `com.example`, artifact id `beer-contracts`, LATEST version and NO classifier
	contractDependency {
		stringNotation = 'com.example:beer-contracts:+:'
	}
	// The JAR with contracts should be taken from Maven local
	contractsMode = "LOCAL"
	// Additional configuration
}
----
* Run the build, generate tests and stubs
+
[source,bash,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
./mvnw clean install
----
+
[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
./gradlew clean build
----
* Write the missing implementation, make the tests pass
* Once done
** merge the pull request to the repository with contract definitions
** you can do it from the command line
+
```bash
$ git commit -am "Finished the implementation to make the contract tests pass"
$ git checkout master
$ git merge --no-ff the_branch_with_pull_request
$ git push origin master
```
* Now, the CI system will build the project with contract definitions and upload the JAR with contract definitions to Nexus / Artifactory
* The producer can switch to working remotely
** Setup the plugin so that the contract definitions are no longer taken from the local storage but from a remote location
+
[source,xml,indent=0,subs="verbatim,attributes",role="primary"]
.Maven
----
<plugin>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-contract-maven-plugin</artifactId>
	<version>${spring-cloud-contract.version}</version>
	<extensions>true</extensions>
	<configuration>
		<!-- We want to use the JAR with contracts with the following coordinates -->
		<contractDependency>
			<groupId>com.example</groupId>
			<artifactId>beer-contracts</artifactId>
		</contractDependency>
		<!-- The JAR with contracts should be taken from a remote location -->
		<contractsMode>REMOTE</contractsMode>
		<!-- ... additional configuration -->
	</configuration>
</plugin>
----
+
[source,groovy,indent=0,subs="verbatim,attributes",role="secondary"]
.Gradle
----
contracts {
	// We want to use the JAR with contracts with the following coordinates
	// group id `com.example`, artifact id `beer-contracts`, LATEST version and NO classifier
	contractDependency {
		stringNotation = 'com.example:beer-contracts:+:'
	}
	// The JAR with contracts should be taken from a remote location
	contractsMode = "REMOTE"
	// Additional configuration
}
----
** merge the producer code with the new implementation
* Now, the CI system will build the project, generate tests, stubs, stub JAR and upload the artifact with the application and the stubs to Nexus / Artifactory

[plantuml, flow-overview-consumer-cdc-external-producer, png]
----
"Producer"->"Repo\nwith\ncontracts": take over the pull request
"Producer"->"Repo\nwith\ncontracts": install the contract\ndefinitions JAR
"Repo\nwith\ncontracts"->"Local storage": install the\ncontract definitions\nJAR locally
"Local storage"->"Repo\nwith\ncontracts": contract definitions\nJAR installed
"Producer"->"Producer\nBuild": run build
"Producer\nBuild"->"SCC\nPlugin": generate tests,\nstubs\nand stub jar
"SCC\nPlugin"->"Local storage": fetch the contract definitions
"Local storage"->"SCC\nPlugin": contract definitions found
"SCC\nPlugin"->"SCC\nPlugin": generate tests
"Producer\nBuild"->"Producer\nBuild": run the\ngenerated tests
"Producer\nBuild"->"Producer": the tests failed to pass
"Producer"->"Producer": write the missing implementation
"Producer"->"Producer\nBuild": run the build again
"Producer\nBuild"->"Producer\nBuild": fetch the contract definitions\nrun the generated tests
"Producer\nBuild"->"Producer": the tests passed
"Producer"->"Repo\nwith\ncontracts": merge the pull request
"Repo\nwith\ncontracts"->"CI": build and upload the\ncontract definitions artifact
"CI"->"Nexus / Artifactory": upload the\ncontract definitions
"Producer"->"Producer": setup the SCC Plugin\nto work remotely
"Producer"->"Producer": merge the code\nwith the implementation
"Producer"->"CI": build and upload\nthe artifacts
"CI"->"Producer\nBuild\non CI": generate tests,\nstubs\nand stub jar
"Producer\nBuild\non CI"->"SCC\nPlugin": generate tests,\nstubs\nand stub jar
"SCC\nPlugin"->"Nexus / Artifactory": fetch the contract definitions
"Nexus / Artifactory"->"SCC\nPlugin": contract definitions found
"SCC\nPlugin"->"SCC\nPlugin": generate tests
"Producer\nBuild\non CI"->"CI": the build passed
"Producer\nBuild\non CI"->"Nexus / Artifactory": upload the application JAR\nand the stubs jar
----

[[flows-cdc-contracts-stubs-git]]
== Consumer Driven Contracts with contracts and stubs in git

[[flows-provider-non-spring]]
== Provider contract testing with stubs in artifactory for a non Spring application

[[flows-provider-non-jvm]]
== Provider contract testing with stubs in artifactory in non JVM world

[[flows-provider-rest-docs]]
== Provider contract testing with REST Docs and stubs in Artifactory


[[using-whats-next]]
== What to Read Next
You should now understand how you can use {project-full-name} and some best practices that you
should follow. You can now go on to learn about specific
_<<project-features#project-features, {project-full-name} features>>_ in depth, or you could
skip ahead and read about the ...
