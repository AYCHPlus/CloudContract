<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.7.1">
<title>Spring Cloud Contract FAQ</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>

</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_spring_cloud_contract_faq">Spring Cloud Contract FAQ</a>
<ul class="sectlevel2">
<li><a href="#_why_use_spring_cloud_contract_verifier_and_not_x">Why use Spring Cloud Contract Verifier and not X ?</a></li>
<li><a href="#_i_dont_want_to_write_a_contract_in_groovy">I don&#8217;t want to write a contract in Groovy!</a></li>
<li><a href="#_what_is_this_valueconsumer_producer">What is this value(consumer(), producer()) ?</a></li>
<li><a href="#_how_to_do_stubs_versioning">How to do Stubs versioning?</a></li>
<li><a href="#_common_repo_with_contracts">Common repo with contracts</a></li>
<li><a href="#_do_i_need_a_binary_storage_cant_i_use_git">Do I need a Binary Storage? Can&#8217;t I use Git?</a></li>
<li><a href="#_can_i_use_the_pact_broker">Can I use the Pact Broker?</a></li>
<li><a href="#_how_can_i_debug_the_requestresponse_being_sent_by_the_generated_tests_client">How can I debug the request/response being sent by the generated tests client?</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_spring_cloud_contract_faq"><a class="link" href="#_spring_cloud_contract_faq">Spring Cloud Contract FAQ</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_why_use_spring_cloud_contract_verifier_and_not_x"><a class="link" href="#_why_use_spring_cloud_contract_verifier_and_not_x">Why use Spring Cloud Contract Verifier and not X ?</a></h3>
<div class="paragraph">
<p>For the time being Spring Cloud Contract is a JVM based tool. So it could be your first pick when you&#8217;re already creating
software for the JVM. This project has a lot of really interesting features but especially quite a few of them definitely make
Spring Cloud Contract Verifier stand out on the "market" of Consumer Driven Contract (CDC) tooling. Out of many the most interesting are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Possibility to do CDC with messaging</p>
</li>
<li>
<p>Clear and easy to use, statically typed DSL</p>
</li>
<li>
<p>Possibility to copy paste your current JSON file to the contract and only edit its elements</p>
</li>
<li>
<p>Automatic generation of tests from the defined Contract</p>
</li>
<li>
<p>Stub Runner functionality - the stubs are automatically downloaded at runtime from Nexus / Artifactory</p>
</li>
<li>
<p>Spring Cloud integration - no discovery service is needed for integration tests</p>
</li>
<li>
<p>Spring Cloud Contract integrates with Pact out of the box and provides easy hooks to extend its functionality</p>
</li>
<li>
<p>Via Docker adds support for any language &amp; framework used</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_i_dont_want_to_write_a_contract_in_groovy"><a class="link" href="#_i_dont_want_to_write_a_contract_in_groovy">I don&#8217;t want to write a contract in Groovy!</a></h3>
<div class="paragraph">
<p>No problem. You can write a contract in YAML!</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_is_this_valueconsumer_producer"><a class="link" href="#_what_is_this_valueconsumer_producer">What is this value(consumer(), producer()) ?</a></h3>
<div class="paragraph">
<p>One of the biggest challenges related to stubs is their reusability. Only if they can be vastly used, will they serve their purpose.
What typically makes that difficult are the hard-coded values of request / response elements. For example dates or ids.
Imagine the following JSON request</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "time" : "2016-10-10 20:10:15",
    "id" : "9febab1c-6f36-4a0b-88d6-3b6a6d81cd4a",
    "body" : "foo"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and JSON response</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "time" : "2016-10-10 21:10:15",
    "id" : "c4231e1f-3ca9-48d3-b7e7-567d55f0d051",
    "body" : "bar"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Imagine the pain required to set proper value of the <code>time</code> field (let&#8217;s assume that this content is generated by the
database) by changing the clock in the system or providing stub implementations of data providers. The same is related
to the field called <code>id</code>. Will you create a stubbed implementation of UUID generator? Makes little sense&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>So as a consumer you would like to send a request that matches any form of a time or any UUID. That way your system
will work as usual - will generate data and you won&#8217;t have to stub anything out. Let&#8217;s assume that in case of the aforementioned
JSON the most important part is the <code>body</code> field. You can focus on that and provide matching for other fields. In other words
you would like the stub to work like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "time" : "SOMETHING THAT MATCHES TIME",
    "id" : "SOMETHING THAT MATCHES UUID",
    "body" : "foo"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As far as the response goes as a consumer you need a concrete value that you can operate on. So such a JSON is valid</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "time" : "2016-10-10 21:10:15",
    "id" : "c4231e1f-3ca9-48d3-b7e7-567d55f0d051",
    "body" : "bar"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you could see in the previous sections we generate tests from contracts. So from the producer&#8217;s side the situation looks
much different. We&#8217;re parsing the provided contract and in the test we want to send a real request to your endpoints.
So for the case of a producer for the request we can&#8217;t have any sort of matching. We need concrete values that the
producer&#8217;s backend can work on. Such a JSON would be a valid one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "time" : "2016-10-10 20:10:15",
    "id" : "9febab1c-6f36-4a0b-88d6-3b6a6d81cd4a",
    "body" : "foo"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>On the other hand from the point of view of the validity of the contract the response doesn&#8217;t necessarily have to
contain concrete values of <code>time</code> or <code>id</code>. Let&#8217;s say that you generate those on the producer side - again, you&#8217;d
have to do a lot of stubbing to ensure that you always return the same values. That&#8217;s why from the producer&#8217;s side
what you might want is the following response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "time" : "SOMETHING THAT MATCHES TIME",
    "id" : "SOMETHING THAT MATCHES UUID",
    "body" : "bar"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>How can you then provide one time a matcher for the consumer and a concrete value for the producer and vice versa?
In Spring Cloud Contract we&#8217;re allowing you to provide a <strong>dynamic value</strong>. That means that it can differ for both
sides of the communication. You can pass the values:</p>
</div>
<div class="paragraph">
<p>Either via the <code>value</code> method</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">value(consumer(...), producer(...))
value(stub(...), test(...))
value(client(...), server(...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>or using the <code>$()</code> method</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">$(consumer(...), producer(...))
$(stub(...), test(...))
$(client(...), server(...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can read more about this in the <a href="#contract-dsl">[contract-dsl]</a> section.</p>
</div>
<div class="paragraph">
<p>Calling <code>value()</code> or <code>$()</code> tells Spring Cloud Contract that you will be passing a dynamic value.
Inside the <code>consumer()</code> method you pass the value that should be used on the consumer side (in the generated stub).
Inside the <code>producer()</code> method you pass the value that should be used on the producer side (in the generated test).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If on one side you have passed the regular expression and you haven&#8217;t passed the other, then the
other side will get auto-generated.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Most often you will use that method together with the <code>regex</code> helper method. E.g. <code>consumer(regex('[0-9]{10}'))</code>.</p>
</div>
<div class="paragraph">
<p>To sum it up the contract for the aforementioned scenario would look more or less like this (the regular expression
for time and UUID are simplified and most likely invalid but we want to keep things very simple in this example):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
				request {
					method 'GET'
					url '/someUrl'
					body([
					    time : value(consumer(regex('[0-9]{4}-[0-9]{2}-[0-9]{2} [0-2][0-9]-[0-5][0-9]-[0-5][0-9]')),
					    id: value(consumer(regex('[0-9a-zA-z]{8}-[0-9a-zA-z]{4}-[0-9a-zA-z]{4}-[0-9a-zA-z]{12}'))
					    body: "foo"
					])
				}
			response {
				status OK()
				body([
					    time : value(producer(regex('[0-9]{4}-[0-9]{2}-[0-9]{2} [0-2][0-9]-[0-5][0-9]-[0-5][0-9]')),
					    id: value([producer(regex('[0-9a-zA-z]{8}-[0-9a-zA-z]{4}-[0-9a-zA-z]{4}-[0-9a-zA-z]{12}'))
					    body: "bar"
					])
			}
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Please read the <a href="https://groovy-lang.org/json.html">Groovy docs related to JSON</a> to understand how to
properly structure the request / response bodies.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_do_stubs_versioning"><a class="link" href="#_how_to_do_stubs_versioning">How to do Stubs versioning?</a></h3>
<div class="sect3">
<h4 id="_api_versioning"><a class="link" href="#_api_versioning">API Versioning</a></h4>
<div class="paragraph">
<p>Let&#8217;s try to answer a question what versioning really means. If you&#8217;re referring to the API version then there are
different approaches.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>use Hypermedia, links and do not version your API by any means</p>
</li>
<li>
<p>pass versions through headers / urls</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I will not try to answer a question which approach is better. Whatever suits your needs and allows you to generate
business value should be picked.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that you do version your API. In that case you should provide as many contracts as many versions you support.
You can create a subfolder for every version or append it to the contract name - whatever suits you more.</p>
</div>
</div>
<div class="sect3">
<h4 id="_jar_versioning"><a class="link" href="#_jar_versioning">JAR versioning</a></h4>
<div class="paragraph">
<p>If by versioning you mean the version of the JAR that contains the stubs then there are essentially two main approaches.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that you&#8217;re doing Continuous Delivery / Deployment which means that you&#8217;re generating a new version of
the jar each time you go through the pipeline and that jar can go to production at any time. For example your jar version
looks like this (it got built on the 20.10.2016 at 20:15:21) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">1.0.0.20161020-201521-RELEASE</code></pre>
</div>
</div>
<div class="paragraph">
<p>In that case your generated stub jar will look like this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">1.0.0.20161020-201521-RELEASE-stubs.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case you should inside your <code>application.yml</code> or <code>@AutoConfigureStubRunner</code> when referencing stubs provide the
 latest version of the stubs. You can do that by passing the <code>+</code> sign. Example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:8080"})</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the versioning however is fixed (e.g. <code>1.0.4.RELEASE</code> or <code>2.1.1</code>) then you have to set the concrete value of the jar
version. Example for 2.1.1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:2.1.1:stubs:8080"})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dev_or_prod_stubs"><a class="link" href="#_dev_or_prod_stubs">Dev or prod stubs</a></h4>
<div class="paragraph">
<p>You can manipulate the classifier to run the tests against current development version of the stubs of other services
 or the ones that were deployed to production. If you alter your build to deploy the stubs with the <code>prod-stubs</code> classifier
 once you reach production deployment then you can run tests in one case with dev stubs and one with prod stubs.</p>
</div>
<div class="paragraph">
<p>Example of tests using development version of stubs</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:8080"})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Example of tests using production version of stubs</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:prod-stubs:8080"})</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can pass those values also via properties from your deployment pipeline.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_common_repo_with_contracts"><a class="link" href="#_common_repo_with_contracts">Common repo with contracts</a></h3>
<div class="paragraph">
<p>Another way of storing contracts other than having them with the producer is keeping them in a common place.
It can be related to security issues where the consumers can&#8217;t clone the producer&#8217;s code. Also if you keep
contracts in a single place then you, as a producer, will know how many consumers you have and which
consumer you will break with your local changes.</p>
</div>
<div class="sect3">
<h4 id="_repo_structure"><a class="link" href="#_repo_structure">Repo structure</a></h4>
<div class="paragraph">
<p>Let&#8217;s assume that we have a producer with coordinates <code>com.example:server</code> and 3 consumers: <code>client1</code>,
<code>client2</code>, <code>client3</code>. Then in the repository with common contracts you would have the following setup
(which you can checkout <a href="https://github.com/spring-cloud/spring-cloud-contract/tree/master/samples/standalone/contracts">here</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">├── com
│   └── example
│       └── server
│           ├── client1
│           │   └── expectation.groovy
│           ├── client2
│           │   └── expectation.groovy
│           ├── client3
│           │   └── expectation.groovy
│           └── pom.xml
├── mvnw
├── mvnw.cmd
├── pom.xml
└── src
    └── assembly
        └── contracts.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see under the slash-delimited groupid <code>/</code> artifact id folder (<code>com/example/server</code>) you have
expectations of the 3 consumers (<code>client1</code>, <code>client2</code> and <code>client3</code>). Expectations are the standard Groovy DSL
contract files as described throughout this documentation. This repository has to produce a JAR file that maps
one to one to the contents of the repo.</p>
</div>
<div class="paragraph">
<p>Example of a <code>pom.xml</code> inside the <code>server</code> folder.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		 xmlns="http://maven.apache.org/POM/4.0.0"
		 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

	&lt;groupId&gt;com.example&lt;/groupId&gt;
	&lt;artifactId&gt;server&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

	&lt;name&gt;Server Stubs&lt;/name&gt;
	&lt;description&gt;POM used to install locally stubs for consumer side&lt;/description&gt;

	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;2.2.0.BUILD-SNAPSHOT&lt;/version&gt;
		&lt;relativePath/&gt;
	&lt;/parent&gt;

	&lt;properties&gt;
		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
		&lt;java.version&gt;1.8&lt;/java.version&gt;
		&lt;spring-cloud-contract.version&gt;2.2.0.BUILD-SNAPSHOT&lt;/spring-cloud-contract.version&gt;
		&lt;spring-cloud-release.version&gt;Hoxton.BUILD-SNAPSHOT&lt;/spring-cloud-release.version&gt;
		&lt;excludeBuildFolders&gt;true&lt;/excludeBuildFolders&gt;
	&lt;/properties&gt;

	&lt;dependencyManagement&gt;
		&lt;dependencies&gt;
			&lt;dependency&gt;
				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
				&lt;version&gt;${spring-cloud-release.version}&lt;/version&gt;
				&lt;type&gt;pom&lt;/type&gt;
				&lt;scope&gt;import&lt;/scope&gt;
			&lt;/dependency&gt;
		&lt;/dependencies&gt;
	&lt;/dependencyManagement&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
				&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
				&lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
				&lt;extensions&gt;true&lt;/extensions&gt;
				&lt;configuration&gt;
					&lt;!-- By default it would search under src/test/resources/ --&gt;
					&lt;contractsDirectory&gt;${project.basedir}&lt;/contractsDirectory&gt;
				&lt;/configuration&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

	&lt;repositories&gt;
		&lt;repository&gt;
			&lt;id&gt;spring-snapshots&lt;/id&gt;
			&lt;name&gt;Spring Snapshots&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;true&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/repository&gt;
		&lt;repository&gt;
			&lt;id&gt;spring-milestones&lt;/id&gt;
			&lt;name&gt;Spring Milestones&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/repository&gt;
		&lt;repository&gt;
			&lt;id&gt;spring-releases&lt;/id&gt;
			&lt;name&gt;Spring Releases&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/repository&gt;
	&lt;/repositories&gt;
	&lt;pluginRepositories&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;spring-snapshots&lt;/id&gt;
			&lt;name&gt;Spring Snapshots&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;true&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;spring-milestones&lt;/id&gt;
			&lt;name&gt;Spring Milestones&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;spring-releases&lt;/id&gt;
			&lt;name&gt;Spring Releases&lt;/name&gt;
			&lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
	&lt;/pluginRepositories&gt;

&lt;/project&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see there are no dependencies other than the Spring Cloud Contract Maven Plugin.
Those poms are necessary for the consumer side to run <code>mvn clean install -DskipTests</code> to locally install
 stubs of the producer project.</p>
</div>
<div class="paragraph">
<p>The <code>pom.xml</code> in the root folder can look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		 xmlns="http://maven.apache.org/POM/4.0.0"
		 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

	&lt;groupId&gt;com.example.standalone&lt;/groupId&gt;
	&lt;artifactId&gt;contracts&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

	&lt;name&gt;Contracts&lt;/name&gt;
	&lt;description&gt;Contains all the Spring Cloud Contracts, well, contracts. JAR used by the
		producers to generate tests and stubs
	&lt;/description&gt;

	&lt;properties&gt;
		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
	&lt;/properties&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
				&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
				&lt;executions&gt;
					&lt;execution&gt;
						&lt;id&gt;contracts&lt;/id&gt;
						&lt;phase&gt;prepare-package&lt;/phase&gt;
						&lt;goals&gt;
							&lt;goal&gt;single&lt;/goal&gt;
						&lt;/goals&gt;
						&lt;configuration&gt;
							&lt;attach&gt;true&lt;/attach&gt;
							&lt;descriptor&gt;${basedir}/src/assembly/contracts.xml&lt;/descriptor&gt;
							&lt;!-- If you want an explicit classifier remove the following line --&gt;
							&lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;
						&lt;/configuration&gt;
					&lt;/execution&gt;
				&lt;/executions&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

&lt;/project&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s using the assembly plugin in order to build the JAR with all the contracts. Example of such setup is here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;assembly xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		  xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3"
		  xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 https://maven.apache.org/xsd/assembly-1.1.3.xsd"&gt;
	&lt;id&gt;project&lt;/id&gt;
	&lt;formats&gt;
		&lt;format&gt;jar&lt;/format&gt;
	&lt;/formats&gt;
	&lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
	&lt;fileSets&gt;
		&lt;fileSet&gt;
			&lt;directory&gt;${project.basedir}&lt;/directory&gt;
			&lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
			&lt;useDefaultExcludes&gt;true&lt;/useDefaultExcludes&gt;
			&lt;excludes&gt;
				&lt;exclude&gt;**/${project.build.directory}/**&lt;/exclude&gt;
				&lt;exclude&gt;mvnw&lt;/exclude&gt;
				&lt;exclude&gt;mvnw.cmd&lt;/exclude&gt;
				&lt;exclude&gt;.mvn/**&lt;/exclude&gt;
				&lt;exclude&gt;src/**&lt;/exclude&gt;
			&lt;/excludes&gt;
		&lt;/fileSet&gt;
	&lt;/fileSets&gt;
&lt;/assembly&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_workflow"><a class="link" href="#_workflow">Workflow</a></h4>
<div class="paragraph">
<p>The workflow would look similar to the one presented in the <code>Step by step guide to CDC</code>. The only difference
 is that the producer doesn&#8217;t own the contracts anymore. So the consumer and the producer have to work on
 common contracts in a common repository.</p>
</div>
</div>
<div class="sect3">
<h4 id="_consumer"><a class="link" href="#_consumer">Consumer</a></h4>
<div class="paragraph">
<p>When the <strong>consumer</strong> wants to work on the contracts offline, instead of cloning the producer code, the
consumer team clones the common repository, goes to the required producer&#8217;s folder (e.g. <code>com/example/server</code>)
and runs <code>mvn clean install -DskipTests</code> to install locally the stubs converted from the contracts.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You need to have <a href="https://maven.apache.org/download.cgi">Maven installed locally</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_producer"><a class="link" href="#_producer">Producer</a></h4>
<div class="paragraph">
<p>As a <strong>producer</strong> it&#8217;s enough to alter the Spring Cloud Contract Verifier to provide the URL and the dependency
of the JAR containing the contracts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	&lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
	&lt;configuration&gt;
		&lt;contractsMode&gt;REMOTE&lt;/contractsMode&gt;
		&lt;contractsRepositoryUrl&gt;
			https://link/to/your/nexus/or/artifactory/or/sth
		&lt;/contractsRepositoryUrl&gt;
		&lt;contractDependency&gt;
			&lt;groupId&gt;com.example.standalone&lt;/groupId&gt;
			&lt;artifactId&gt;contracts&lt;/artifactId&gt;
		&lt;/contractDependency&gt;
	&lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this setup the JAR with groupid <code>com.example.standalone</code> and artifactid <code>contracts</code> will be downloaded
from <code><a href="https://link/to/your/nexus/or/artifactory/or/sth" class="bare">https://link/to/your/nexus/or/artifactory/or/sth</a></code>. It will be then unpacked in a local temporary folder
and contracts present under the <code>com/example/server</code> will be picked as the ones used to generate the
tests and the stubs. Due to this convention the producer team will know which consumer teams will be broken
when some incompatible changes are done.</p>
</div>
<div class="paragraph">
<p>The rest of the flow looks the same.</p>
</div>
</div>
<div class="sect3">
<h4 id="_how_can_i_define_messaging_contracts_per_topic_not_per_producer"><a class="link" href="#_how_can_i_define_messaging_contracts_per_topic_not_per_producer">How can I define messaging contracts per topic not per producer?</a></h4>
<div class="paragraph">
<p>To avoid messaging contracts duplication in the common repo, when few producers writing messages to one topic,
we could create the structure when the rest contracts would be placed in a folder per producer and messaging
contracts in the folder per topic.</p>
</div>
<div class="sect4">
<h5 id="_for_maven_project"><a class="link" href="#_for_maven_project">For Maven Project</a></h5>
<div class="paragraph">
<p>To make it possible to work on the producer side we should specify an inclusion pattern for
filtering common repository jar by messaging topics we are interested in. <code><code>includedFiles</code></code> property of <code><code>Maven Spring Cloud Contract plugin</code></code>
allows us to do that. Also <code><code>contractsPath</code></code> need to be specified since the default path would be the common repository <code><code>groupid/artifactid</code></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
   &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
   &lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
   &lt;configuration&gt;
      &lt;contractsMode&gt;REMOTE&lt;/contractsMode&gt;
      &lt;contractsRepositoryUrl&gt;https://link/to/your/nexus/or/artifactory/or/sth&lt;/contractsRepositoryUrl&gt;
      &lt;contractDependency&gt;
         &lt;groupId&gt;com.example&lt;/groupId&gt;
         &lt;artifactId&gt;common-repo-with-contracts&lt;/artifactId&gt;
         &lt;version&gt;+&lt;/version&gt;
      &lt;/contractDependency&gt;
      &lt;contractsPath&gt;/&lt;/contractsPath&gt;
      &lt;baseClassMappings&gt;
         &lt;baseClassMapping&gt;
            &lt;contractPackageRegex&gt;.*messaging.*&lt;/contractPackageRegex&gt;
            &lt;baseClassFQN&gt;com.example.services.MessagingBase&lt;/baseClassFQN&gt;
         &lt;/baseClassMapping&gt;
         &lt;baseClassMapping&gt;
            &lt;contractPackageRegex&gt;.*rest.*&lt;/contractPackageRegex&gt;
            &lt;baseClassFQN&gt;com.example.services.TestBase&lt;/baseClassFQN&gt;
         &lt;/baseClassMapping&gt;
      &lt;/baseClassMappings&gt;
      &lt;includedFiles&gt;
         &lt;includedFile&gt;**/${project.artifactId}/**&lt;/includedFile&gt;
         &lt;includedFile&gt;**/${first-topic}/**&lt;/includedFile&gt;
         &lt;includedFile&gt;**/${second-topic}/**&lt;/includedFile&gt;
      &lt;/includedFiles&gt;
   &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_for_gradle_project"><a class="link" href="#_for_gradle_project">For Gradle Project</a></h5>
<div class="ulist">
<ul>
<li>
<p>Add a custom configuration for the common-repo dependency:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">ext {
    conractsGroupId = "com.example"
    contractsArtifactId = "common-repo"
    contractsVersion = "1.2.3"
}

configurations {
    contracts {
        transitive = false
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Add the common-repo dependency to your classpath:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
    contracts "${conractsGroupId}:${contractsArtifactId}:${contractsVersion}"
    testCompile "${conractsGroupId}:${contractsArtifactId}:${contractsVersion}"
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Download the dependency to an appropriate folder:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">task getContracts(type: Copy) {
    from configurations.contracts
    into new File(project.buildDir, "downloadedContracts")
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Unzip JAR:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">task unzipContracts(type: Copy) {
    def zipFile = new File(project.buildDir, "downloadedContracts/${contractsArtifactId}-${contractsVersion}.jar")
    def outputDir = file("${buildDir}/unpackedContracts")

    from zipTree(zipFile)
    into outputDir
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Cleanup unused contracts:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">task deleteUnwantedContracts(type: Delete) {
    delete fileTree(dir: "${buildDir}/unpackedContracts",
        include: "**/*",
        excludes: [
            "**/${project.name}/**"",
            "**/${first-topic}/**",
            "**/${second-topic}/**"])
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Create task dependencies:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">unzipContracts.dependsOn("getContracts")
deleteUnwantedContracts.dependsOn("unzipContracts")
build.dependsOn("deleteUnwantedContracts")</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Configure plugin by specifying the directory containing contracts using <code>contractsDslDir</code> property</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">contracts {
    contractsDslDir = new File("${buildDir}/unpackedContracts")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_do_i_need_a_binary_storage_cant_i_use_git"><a class="link" href="#_do_i_need_a_binary_storage_cant_i_use_git">Do I need a Binary Storage? Can&#8217;t I use Git?</a></h3>
<div class="paragraph">
<p>In the polyglot world, there are languages that don&#8217;t use binary storages like
Artifactory or Nexus. Starting from Spring Cloud Contract version 2.0.0 we provide
mechanisms to store contracts and stubs in a SCM repository. Currently the
only supported SCM is Git.</p>
</div>
<div class="paragraph">
<p>The repository would have to the following setup
(which you can checkout <a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x/contracts_git/">here</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>.
└── META-INF
    └── com.example
        └── beer-api-producer-git
            └── 0.0.1-SNAPSHOT
                ├── contracts
                │   └── beer-api-consumer
                │       ├── messaging
                │       │   ├── shouldSendAcceptedVerification.groovy
                │       │   └── shouldSendRejectedVerification.groovy
                │       └── rest
                │           ├── shouldGrantABeerIfOldEnough.groovy
                │           └── shouldRejectABeerIfTooYoung.groovy
                └── mappings
                    └── beer-api-consumer
                        └── rest
                            ├── shouldGrantABeerIfOldEnough.json
                            └── shouldRejectABeerIfTooYoung.json</code></pre>
</div>
</div>
<div class="paragraph">
<p>Under <code>META-INF</code> folder:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>we group applications via <code>groupId</code> (e.g. <code>com.example</code>)</p>
</li>
<li>
<p>then each application is represented via the <code>artifactId</code> (e.g. <code>beer-api-producer-git</code>)</p>
</li>
<li>
<p>next, the version of the application (e.g. <code>0.0.1-SNAPSHOT</code>). Starting from Spring Cloud Contract version <code>2.1.0</code>, you can specify the versions as follows (assuming that your versions follow the semantic versioning)</p>
<div class="ulist">
<ul>
<li>
<p><code>+</code> or <code>latest</code> - to find the latest version of your stubs (assuming that the snapshots are always the latest artifact for a given revision number). That means:</p>
<div class="ulist">
<ul>
<li>
<p>if you have a version <code>1.0.0.RELEASE</code>, <code>2.0.0.BUILD-SNAPSHOT</code> and <code>2.0.0.RELEASE</code> we will assume that the latest is <code>2.0.0.BUILD-SNAPSHOT</code></p>
</li>
<li>
<p>if you have a version <code>1.0.0.RELEASE</code> and <code>2.0.0.RELEASE</code> we will assume that the latest is <code>2.0.0.RELEASE</code></p>
</li>
<li>
<p>if you have a version called <code>latest</code> or <code>+</code> we will pick that folder</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>release</code> - to find the latest release version of your stubs. That means:</p>
<div class="ulist">
<ul>
<li>
<p>if you have a version <code>1.0.0.RELEASE</code>, <code>2.0.0.BUILD-SNAPSHOT</code> and <code>2.0.0.RELEASE</code> we will assume that the latest is <code>2.0.0.RELEASE</code></p>
</li>
<li>
<p>if you have a version called <code>release</code> we will pick that folder</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>finally, there are two folders:</p>
<div class="ulist">
<ul>
<li>
<p><code>contracts</code> - the good practice is to store the contracts required by each
consumer in the folder with the consumer name (e.g. <code>beer-api-consumer</code>). That way you
can use the <code>stubs-per-consumer</code> feature. Further directory structure is arbitrary.</p>
</li>
<li>
<p><code>mappings</code> - in this folder the Maven / Gradle Spring Cloud Contract plugins will push
the stub server mappings. On the consumer side, Stub Runner will scan this folder
to start stub servers with stub definitions. The folder structure will be a copy
of the one created in the <code>contracts</code> subfolder.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_protocol_convention"><a class="link" href="#_protocol_convention">Protocol convention</a></h4>
<div class="paragraph">
<p>In order to control the type and location of the source of contracts (whether it&#8217;s
a binary storage or an SCM repository), you can use the protocol in the URL of
the repository. Spring Cloud Contract iterates over registered protocol resolvers
and tries to fetch the contracts (via a plugin) or stubs (via Stub Runner).</p>
</div>
<div class="paragraph">
<p>For the SCM functionality, currently, we support the Git repository. To use it,
in the property, where the repository URL needs to be placed you just have to prefix
the connection URL with <code>git://</code>. Here you can find a couple of examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>git://file:///foo/bar
git://https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git
git://git@github.com:spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_producer_2"><a class="link" href="#_producer_2">Producer</a></h4>
<div class="paragraph">
<p>For the producer, to use the SCM approach, we can reuse the
same mechanism we use for external contracts. We route Spring Cloud Contract
to use the SCM implementation via the URL that contains
the <code>git://</code> protocol.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You have to manually add the <code>pushStubsToScm</code>
goal in Maven or execute (bind) the <code>pushStubsToScm</code> task in
Gradle. We don&#8217;t push stubs to <code>origin</code> of your git
repository out of the box.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
    &lt;extensions&gt;true&lt;/extensions&gt;
    &lt;configuration&gt;
        &lt;!-- Base class mappings etc. --&gt;

        &lt;!-- We want to pick contracts from a Git repository --&gt;
        &lt;contractsRepositoryUrl&gt;git://https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git&lt;/contractsRepositoryUrl&gt;

        &lt;!-- We reuse the contract dependency section to set up the path
        to the folder that contains the contract definitions. In our case the
        path will be /groupId/artifactId/version/contracts --&gt;
        &lt;contractDependency&gt;
            &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;
            &lt;artifactId&gt;${project.artifactId}&lt;/artifactId&gt;
            &lt;version&gt;${project.version}&lt;/version&gt;
        &lt;/contractDependency&gt;

        &lt;!-- The contracts mode can't be classpath --&gt;
        &lt;contractsMode&gt;REMOTE&lt;/contractsMode&gt;
    &lt;/configuration&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;!-- By default we will not push the stubs back to SCM,
                you have to explicitly add it as a goal --&gt;
                &lt;goal&gt;pushStubsToScm&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">contracts {
	// We want to pick contracts from a Git repository
	contractDependency {
		stringNotation = "${project.group}:${project.name}:${project.version}"
	}
	/*
	We reuse the contract dependency section to set up the path
	to the folder that contains the contract definitions. In our case the
	path will be /groupId/artifactId/version/contracts
	 */
	contractRepository {
		repositoryUrl = "git://https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git"
	}
	// The mode can't be classpath
	contractsMode = "REMOTE"
	// Base class mappings etc.
}

/*
In this scenario we want to publish stubs to SCM whenever
the `publish` task is executed
*/
publish.dependsOn("publishStubsToScm")</code></pre>
</div>
</div>
<div class="paragraph">
<p>With such a setup:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Git project will be cloned to a temporary directory</p>
</li>
<li>
<p>The SCM stub downloader will go to <code>META-INF/groupId/artifactId/version/contracts</code> folder
to find contracts. E.g. for <code>com.example:foo:1.0.0</code> the path would be
<code>META-INF/com.example/foo/1.0.0/contracts</code></p>
</li>
<li>
<p>Tests will be generated from the contracts</p>
</li>
<li>
<p>Stubs will be created from the contracts</p>
</li>
<li>
<p>Once the tests pass, the stubs will be committed in the cloned repository</p>
</li>
<li>
<p>Finally, a push will be done to that repo&#8217;s <code>origin</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_producer_with_contracts_stored_locally"><a class="link" href="#_producer_with_contracts_stored_locally">Producer with contracts stored locally</a></h4>
<div class="paragraph">
<p>Another option to use the SCM as the destination for stubs and contracts is to store the contracts locally, with the producer, and only push the contracts and the stubs to SCM. Below, you can find the setup required to achieve this using Maven and Gradle.</p>
</div>
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"></code></pre>
</div>
</div>
<div class="paragraph">
<p>With such a setup:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Contracts from the default <code>src/test/resources/contracts</code> directory will be picked</p>
</li>
<li>
<p>Tests will be generated from the contracts</p>
</li>
<li>
<p>Stubs will be created from the contracts</p>
</li>
<li>
<p>Once the tests pass</p>
<div class="ulist">
<ul>
<li>
<p>Git project will be cloned to a temporary directory</p>
</li>
<li>
<p>The stubs and contracts will be committed in the cloned repository</p>
</li>
</ul>
</div>
</li>
<li>
<p>Finally, a push will be done to that repo&#8217;s <code>origin</code></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_keeping_contracts_with_the_producer_and_stubs_in_an_external_repository"><a class="link" href="#_keeping_contracts_with_the_producer_and_stubs_in_an_external_repository">Keeping contracts with the producer and stubs in an external repository</a></h5>
<div class="paragraph">
<p>It is also possible to keep the contracts in the producer repository, but keep the stubs in an external git repo.
This is most useful when you want to use the base consumer-producer collaboration flow, but do not have a possibility to
use an artifact repository for storing the stubs.</p>
</div>
<div class="paragraph">
<p>In order to do that, use the usual producer setup, and then add the <code>pushStubsToScm</code> goal and set
<code>contractsRepositoryUrl</code> to the repository where you want to keep the stubs.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_consumer_2"><a class="link" href="#_consumer_2">Consumer</a></h4>
<div class="paragraph">
<p>On the consumer side when passing the <code>repositoryRoot</code> parameter,
either from the <code>@AutoConfigureStubRunner</code> annotation, the
JUnit rule, JUnit 5 extension or properties, it&#8217;s enough to pass the URL of the
SCM repository, prefixed with the protocol. For example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(
    stubsMode="REMOTE",
    repositoryRoot="git://https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git",
    ids="com.example:bookstore:0.0.1.RELEASE"
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>With such a setup:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Git project will be cloned to a temporary directory</p>
</li>
<li>
<p>The SCM stub downloader will go to <code>META-INF/groupId/artifactId/version/</code> folder
to find stub definitions and contracts. E.g. for <code>com.example:foo:1.0.0</code> the path would be
<code>META-INF/com.example/foo/1.0.0/</code></p>
</li>
<li>
<p>Stub servers will be started and fed with mappings</p>
</li>
<li>
<p>Messaging definitions will be read and used in the messaging tests</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_can_i_use_the_pact_broker"><a class="link" href="#_can_i_use_the_pact_broker">Can I use the Pact Broker?</a></h3>
<div class="paragraph">
<p>When using <a href="https://pact.io/">Pact</a> you can use the <a href="https://github.com/pact-foundation/pact_broker">Pact Broker</a>
to store and share Pact definitions. Starting from Spring Cloud Contract
2.0.0 one can fetch Pact files from the Pact Broker to generate
tests and stubs.</p>
</div>
<div class="paragraph">
<p>As a prerequisite the Pact Converter and Pact Stub Downloader
are required. You have to add them via the <code>spring-cloud-contract-pact</code> dependency.
You can read more about it in the <a href="#pact-converter">[pact-converter]</a> section.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Pact follows the Consumer Contract convention. That means
that the Consumer creates the Pact definitions first, then
shares the files with the Producer. Those expectations are generated
from the Consumer&#8217;s code and can break the Producer if the expectations
are not met.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_pact_consumer"><a class="link" href="#_pact_consumer">Pact Consumer</a></h4>
<div class="paragraph">
<p>The consumer uses Pact framework to generate Pact files. The
Pact files are sent to the Pact Broker. An example of such
setup can be found <a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x/consumer_pact">here</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_producer_3"><a class="link" href="#_producer_3">Producer</a></h4>
<div class="paragraph">
<p>For the producer, to use the Pact files from the Pact Broker, we can reuse the
same mechanism we use for external contracts. We route Spring Cloud Contract
to use the Pact implementation via the URL that contains
the <code>pact://</code> protocol. It&#8217;s enough to pass the URL to the
Pact Broker. An example of such setup can be found <a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x/producer_pact">here</a>.</p>
</div>
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
    &lt;extensions&gt;true&lt;/extensions&gt;
    &lt;configuration&gt;
        &lt;!-- Base class mappings etc. --&gt;

        &lt;!-- We want to pick contracts from a Git repository --&gt;
        &lt;contractsRepositoryUrl&gt;pact://http://localhost:8085&lt;/contractsRepositoryUrl&gt;

        &lt;!-- We reuse the contract dependency section to set up the path
        to the folder that contains the contract definitions. In our case the
        path will be /groupId/artifactId/version/contracts --&gt;
        &lt;contractDependency&gt;
            &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;
            &lt;artifactId&gt;${project.artifactId}&lt;/artifactId&gt;
            &lt;!-- When + is passed, a latest tag will be applied when fetching pacts --&gt;
            &lt;version&gt;+&lt;/version&gt;
        &lt;/contractDependency&gt;

        &lt;!-- The contracts mode can't be classpath --&gt;
        &lt;contractsMode&gt;REMOTE&lt;/contractsMode&gt;
    &lt;/configuration&gt;
    &lt;!-- Don't forget to add spring-cloud-contract-pact to the classpath! --&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-contract-pact&lt;/artifactId&gt;
            &lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">buildscript {
	repositories {
		//...
	}

	dependencies {
		// ...
		// Don't forget to add spring-cloud-contract-pact to the classpath!
		classpath "org.springframework.cloud:spring-cloud-contract-pact:${contractVersion}"
	}
}

contracts {
	// When + is passed, a latest tag will be applied when fetching pacts
	contractDependency {
		stringNotation = "${project.group}:${project.name}:+"
	}
	contractRepository {
		repositoryUrl = "pact://http://localhost:8085"
	}
	// The mode can't be classpath
	contractsMode = "REMOTE"
	// Base class mappings etc.
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With such a setup:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Pact files will be downloaded from the Pact Broker</p>
</li>
<li>
<p>Spring Cloud Contract will convert the Pact files into tests and stubs</p>
</li>
<li>
<p>The JAR with the stubs gets automatically created as usual</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_pact_consumer_producer_contract_approach"><a class="link" href="#_pact_consumer_producer_contract_approach">Pact Consumer (Producer Contract approach)</a></h4>
<div class="paragraph">
<p>In the scenario where you don&#8217;t want to do Consumer Contract approach
(for every single consumer define the expectations) but you&#8217;d prefer
to do Producer Contracts (the producer provides the contracts and
publishes stubs), it&#8217;s enough to use Spring Cloud Contract with
Stub Runner option. An example of such setup can be found <a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x/consumer_pact_stubrunner">here</a>.</p>
</div>
<div class="paragraph">
<p>First, remember to add Stub Runner and Spring Cloud Contract Pact module
as test dependencies.</p>
</div>
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;!-- Don't forget to add spring-cloud-contract-pact to the classpath! --&gt;
&lt;dependencies&gt;
    &lt;!-- ... --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-contract-stub-runner&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-contract-pact&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
    }
}

dependencies {
    //...
    testCompile("org.springframework.cloud:spring-cloud-starter-contract-stub-runner")
    // Don't forget to add spring-cloud-contract-pact to the classpath!
    testCompile("org.springframework.cloud:spring-cloud-contract-pact")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, just pass the URL of the Pact Broker to <code>repositoryRoot</code>, prefixed
with <code>pact://</code> protocol. E.g. <code>pact://http://localhost:8085</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureStubRunner(stubsMode = StubRunnerProperties.StubsMode.REMOTE,
		ids = "com.example:beer-api-producer-pact",
		repositoryRoot = "pact://http://localhost:8085")
public class BeerControllerTest {
    //Inject the port of the running stub
    @StubRunnerPort("beer-api-producer-pact") int producerPort;
    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With such a setup:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Pact files will be downloaded from the Pact Broker</p>
</li>
<li>
<p>Spring Cloud Contract will convert the Pact files into stub definitions</p>
</li>
<li>
<p>The stub servers will be started and fed with stubs</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information about Pact support you can go to
the <a href="#pact-stub-downloader">[pact-stub-downloader]</a> section.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_can_i_debug_the_requestresponse_being_sent_by_the_generated_tests_client"><a class="link" href="#_how_can_i_debug_the_requestresponse_being_sent_by_the_generated_tests_client">How can I debug the request/response being sent by the generated tests client?</a></h3>
<div class="paragraph">
<p>The generated tests all boil down to RestAssured in some form or fashion which relies on <a href="https://hc.apache.org/httpcomponents-client-ga/">Apache HttpClient</a>.  HttpClient has a facility called <a href="https://hc.apache.org/httpcomponents-client-ga/logging.html#Wire_Logging">wire logging</a> which logs the entire request and response to HttpClient.  Spring Boot has a logging <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html">common application property</a> for doing this sort of thing, just add this to your application properties</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">logging.level.org.apache.http.wire=DEBUG</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_how_can_i_debug_the_mappingrequestresponse_being_sent_by_wiremock"><a class="link" href="#_how_can_i_debug_the_mappingrequestresponse_being_sent_by_wiremock">How can I debug the mapping/request/response being sent by WireMock?</a></h4>
<div class="paragraph">
<p>Starting from version <code>1.2.0</code> we turn on WireMock logging to
info and the WireMock notifier to being verbose. Now you will
exactly know what request was received by WireMock server and which
matching response definition was picked.</p>
</div>
<div class="paragraph">
<p>To turn off this feature just bump WireMock logging to <code>ERROR</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">logging.level.com.github.tomakehurst.wiremock=ERROR</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_how_can_i_see_what_got_registered_in_the_http_server_stub"><a class="link" href="#_how_can_i_see_what_got_registered_in_the_http_server_stub">How can I see what got registered in the HTTP server stub?</a></h4>
<div class="paragraph">
<p>You can use the <code>mappingsOutputFolder</code> property on <code>@AutoConfigureStubRunner</code>, <code>StubRunnerRule</code> or
`StubRunnerExtension`to dump all mappings per artifact id. Also the port at which the given stub server
was started will be attached.</p>
</div>
</div>
<div class="sect3">
<h4 id="_can_i_reference_text_from_file"><a class="link" href="#_can_i_reference_text_from_file">Can I reference text from file?</a></h4>
<div class="paragraph">
<p>Yes! With version 1.2.0 we&#8217;ve added such a possibility. It&#8217;s enough to call <code>file(&#8230;&#8203;)</code> method in the
DSL and provide a path relative to where the contract lays.
If you&#8217;re using YAML just use the <code>bodyFromFile</code> property.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<link rel="stylesheet" href="js/highlight/styles/atom-one-dark-reasonable.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>